import numpy as np
cimport numpy as np
np.import_array()
from libcpp.complex cimport complex
from cython cimport view

#cimport Block
#ctypedef complex[double] Complex
cdef extern from "Block.h" namespace "Uni10":
	
	cdef enum rflag:
		RNULL = 0
		RTYPE = 1

	cdef enum cflag:
		CNULL = 0
		CTYPE = 2

	cdef cppclass Block:
		Block()
		Block(size_t _Rnum, size_t _Cnum)
		Block(rflag uni10_tp, size_t _Rnum, size_t _Cnum)
		Block(cflag uni10_tp, size_t _Rnum, size_t _Cnum)
		size_t elemNum()
		size_t row()
		size_t col()
		int typeID()
		void setElem(double* _elem)
		void setElem(complex[double]* _elem)
		double* getElem()
		complex[double]* getElem(cflag uni10_tp);

cdef class pyBlock:

	cdef Block *_thisptr

	def __cinit__(self, str uni10_tp, unsigned long _Rnum, unsigned long _Cnum):
			
		if uni10_tp == "R":
			self._thisptr = new Block(RTYPE, _Rnum, _Cnum)
		elif uni10_tp == "C":
			self._thisptr = new Block(CTYPE, _Rnum, _Cnum)
		elif self._thisptr == NULL:
			raise MemoryError()

	def __dealloc__(self):
		if self._thisptr != NULL:
			del self._thisptr

	def __str__(self):
		os = str(self._thisptr.row()) + ' x ' + str(self._thisptr.col()) + ' = ' + str(self._thisptr.elemNum()) + "\n\n"
		typeID = self._thisptr.typeID()
		cdef double* r_elem_ptr = NULL
		cdef complex[double]* c_elem_ptr = NULL
		_Rnum = self._thisptr.row()
		_Cnum = self._thisptr.col()
			
		buf_arr = self.getElem()
		print '====================='
		print buf_arr
		print '=======End============='
		for i in xrange(_Rnum):
			for j in xrange(_Cnum):
				os + "  " + str(buf_arr[i*_Cnum + j])	
	#	elif typeID == 2:
	#		c_elem_ptr = self._thisptr.getElem(CTYPE)
	#		for i in xrange(_Rnum):
	#			for j in xrange(_Cnum):
	#				os + "  " + str(c_elem_ptr[i*_Cnum + j])	

		os + '\n\n'	
	
		return os
		
	
	cpdef unsigned long elemNum(self):
		return self._thisptr.elemNum()

	cpdef long typeID(self):
		return self._thisptr.typeID()

	cpdef void setElem(self, np.ndarray A):
		arr_type = 0
		
		if A.dtype == np.float64:
			arr_type = np.float64
		elif A.dtype == np.complex128:
			arr_type = np.complex128
		else:
			print "Type Error !!!!"

		cdef np.ndarray A_buf = A.astype(arr_type, copy=True)

		if A.dtype == np.dtype(float):
			self._thisptr.setElem(<double*> A_buf.data)
		if A.dtype == np.complex128:
			self._thisptr.setElem(<complex[double]*> A_buf.data)
	
	cpdef np.ndarray getElem(self):
		typeID = self._thisptr.typeID()
		arr_type = 0

		if typeID == 1:
			arr_type = np.float64
		elif typeID == 2:
			arr_type = np.complex128
		else:
			print "Type Error !!!!"

		
		#cdef  np.ndarray r_arr = np.array(dtype = 'float64')
		#r_arr.data = <np.float64_t[:4]> self._thisptr.getElem()
		#cdef  np.ndarray c_arr = np.array(dtype = 'complex128')
		#c_arr.data = <complex[double]*> self._thisptr.getElem(CTYPE)
		#for i in xrange(4):
		#	self_th	
		np_arr = <np.float64_t[:4]> self._thisptr.getElem()
		print np_arr
		print '###############'
		if typeID == 1:
			arr = <double[:self._thisptr.elemNum()]> self._thisptr.getElem()
		elif typeID == 2:
			print "Fuck you"
			#arr = <np.complex128_t[:self._thisptr.elemNum()]> self._thisptr.getElem(CTYPE)
		print '###############'
		print arr.size()


		return arr
				

